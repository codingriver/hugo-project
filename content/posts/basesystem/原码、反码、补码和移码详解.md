
---
title: "原码、反码、补码和移码详解"
date: 2019-12-01T21:57:40+08:00
tags: [""]
categories: ["计算机基础"]
---

<!--more-->


>      到目前为止，我们学习了十进制、二进制、八进制、十六进制等用来代表实际数值的数，称为真值，这些数我们再日常生活中都会使用到，那么在计算机中数值是怎么来表示的呢？
>      数在计算机中的表示形式统称为机器数。计算机中处理数据及运算都是采用二进制，通常规定机器数用八位二进制表示。实用的数据有正数和负数，因为计算机只能表示0、1两种状态，数据的正号“+”或负号“-”，在计算机里就用一位二进制的0或1来区别，通常放在最高位，成为符号位。 符号位数值化之后，为能方便的对机器数进行算术运算、提高运算速度，计算机设计了多种符号位与数值一起编码的方法，最常用的机器数表示方法有:原码、反码、补码和移码，下面就分别介绍一下它们的表示方法。
#  0X01 原码、反码、补码和移码
+ **原码：正数是其二进制本身；负数是符号位为1,数值部分取X绝对值的二进制。**
+ **反码：正数的反码和原码相同；负数是符号位为1,其它位是原码取反。**
+ **补码：正数的补码和原码，反码相同；负数是符号位为1，其它位是原码取反，未位加1。（或者说负数的补码是其绝对值反码未位加1）**
+ **移码：将符号位取反的补码（不区分正负）**

举个例子以一个字节8位说明：  

|编码|108<sub>10</sub>（sbyte）|-108<sub>10</sub>（sbyte）|
|-|-|-|
|原码|**0**1101100|**1**1101100|
|反码|**0**1101100|**1**0010011|
|补码|**0**1101100|**1**0010100|
|移码|**1**1101100|**0**0010100|
*注：加粗的数字为符号位，[补码在线工具](http://www.99cankao.com/numbers/twos-complement.php)*
  移码表示法是在数X上增加一个偏移量来定义的，常用来表示浮点数中的阶码，所以是整数。如果机器字长为n，规定偏移量为2<sup>(n-1)</sup>。若X是整数，则X<sub>移</sub>=2^(n-1)+X
例子：假设字长为8，以上面的108为例
 108<sub>移</sub>=10000000+**0**1101100=**1**1101100
-108<sub>移</sub>=10000000+**1**0010100=**0**0010100

# 0X02 补码求原码
已知一个数的补码，求原码的操作分两种情况：
 如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。
如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1；其余各位取反，然后再整个数加1。

# 0X03 补码加、减运算公式
+ **在做补码加减法时，只需将符号位和数值部分一起参与运算，并且将符号位产生的进位丢掉即可**
+  补码加法公式
  [X+Y]补 ＝ [X]补 + [Y]补
+   补码减法公式  
  [X-Y]补 =  [X]补-[Y]补 = [X]补 + [-Y]补
其中：[-Y]补称为负补,求负补的办法是：对补码的每一位(包括符合位)求反，且未位加1.

*假设字长为8的计算机sbyte类型所能表示的最大数是11111111，若再加1称为100000000(9位)，但因只有8位，最高位1自然丢失。又回了00000000，所以字长为8的二进制系统的模为2^8。*

# 0X04 为何要使用原码, 反码和补码
在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub>

所以不需要过多解释. 但是对于负数:

[-1] = [10000001]<sub>原</sub>= [11111110]<sub>反</sub>= [11111111]<sub>补</sub>

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (补码的绝对值称为真值即去掉符号位的二进制数字). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]<sub>原</sub> + [10000001]<sub>原</sub>= [10000010]<sub>原</sub> = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub>= [0000 0001]<sub>反</sub>+ [1111 1110]<sub>反</sub>= [1111 1111]<sub>反</sub>= [1000 0000]<sub>原</sub>= -0

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]<sub>原</sub>和[1000 0000]<sub>原</sub>两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

1-1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0001]<sub>补</sub>+ [1111 1111]<sub>补</sub>= [0000 0000]<sub>补</sub>=[0000 0000]<sub>原</sub>

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub>+ [1000 0001]<sub>补</sub>= [1000 0000]<sub>补</sub>

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]<sub>补</sub>就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]<sub>补</sub>算出来的原码是[0000 0000]<sub>原</sub>, 这是不正确的)

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-2<sup>31</sup>, 2<sup>31</sup>-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

总结：
+ **原码负数不能参与运算并且不能做减法运算**
+ **反码的+0和-0的反码不相同**
+ **-128在运算中的补码是 [1000 0000]<sub>补</sub>，并没有原码和反码表示**

> 引用的文章: 
> http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html
> http://blog.csdn.net/peng_weida/article/details/7931990
>[补码和原码的转化过程](https://blog.csdn.net/q_l_s/article/details/54894897)
