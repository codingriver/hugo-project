---
title: "unity性能优化总结"
date: 2019-12-01T21:57:40+08:00
draft: true
author: "codingriver"
authorLink: "https://codingriver.github.io"
tags: [""]
categories: [""]
---

<!--more-->


### 一、内存的优化：
>Unity中的内存种类
>实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。 

#### 优化程序代码的内存占用
- 1 API兼容性级别选择.net2.0子集（不需要Unity将全部.NET的Api包含进去）
- 2剥离级别选择剥离字符集（示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分）
 
#### 托管堆优化

1. 建立缓存池
1. 在卸载场景时调用System.GC.Collect()（调用System.GC.Collect() 会卡顿）
1. 尽量不要用foreach（带来24字节）
1. 不要直接访问gameobject的tag属性(可以用if (go.CompareTag (“human”))， 因为访问物体的tag属性会在堆上额外的分配空间)
1. Debug.Log 游戏发布关闭 Log 减少性能消耗
 
#### 本机堆的优化

- 1 纹理
- 1.1使用png格式
- 1.2关闭纹理资源的read/write功能（增加1倍） ui不适用mipmap（增加1/3）
- 1.3非二次幂的纹理（不压缩 ，ui图集，可以是非正方形）
- 1.4Ui的背景可以适当的压缩，其他ui资源不压缩（防止糊了）
- 1.5Android平台贴图压缩用etc2 8bit，占用原来的1/4内存（etc 8bit注意下）
- 1.6Ios平台贴图压缩用pvrtc 4bit 占用原来的1/8内存（必须是正方形）
- 1.7压缩贴图的话贴图本身必须是二次幂的
- 2 音频
- 2.1 背景音乐使用压缩的ogg或者mp3，像攻击音效等使用wav
- 2.2 背景音乐等长的音频使用在内存中压缩(Compressed in memory)的加载类型
- 2.3 攻击音效等短的音频使用加载时解压(Decompress on load)的加载类型
- 2.4 加载时解压是在内存中压缩的10倍内存， 但是像攻击音效等短的音效如果用在内存中压缩的加载类型的话会有延时（需要先解压），这样体验不好（本来音频就很短）
- 3 网格
- 3.1模型资源不要开启read/write  使用 Mesh Compression 压缩网格
- 3.2 不要使用自带的球体网格，面数太多

### 二、CPU的方面的优化： 
>Drawcall：
>Drawcall是啥？其实就是对底层图形程序（比如：OpenGL ES)接口的调用，以在屏幕上画出东西。

#### DrawCall如何优化：
- 1	使用Draw Call Batching，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，从而用一个描绘调用来渲染他们。
  - 静态批处理Static Batching，只要是静态不动的物体且具有相同材质的话就可以使用静态批处理来降低描绘调用（注：shader不同则会增加纹理的拼合降低渲染效率）
  - 动态批处理Dynamic Batching：动态批处理是引擎自动进行，无需设置，当物体共享相同的材质，则引擎就会自动对Drawcall进行优化，也就是动态批处理（如实例化预制件）。动态批处理存在约束，稍有不慎就会增加Drawcall
    >动态批处理的约束：  
    > 1、批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。  
    >2、如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。  
    >3、不要使用缩放。分别拥有缩放大小(1,1,1) 和(2,2,2)的两个物体将不会进行批处理。  
    >4、统一缩放的物体不会与非统一缩放的物体进行批处理。  
    >5、使用缩放尺度(1,1,1) 和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1) 和(1,3,1)的两个物体将可以进行批处理。  
    >6、使用不同材质的实例化物体（instance）将会导致批处理失败。  
    >7、拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。  
    >8、多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。  
    >9、预设体的实例会自动地使用相同的网格模型和材质。  
    >所以尽量使用静态批处理。


- 2	打包图集
- 3	使用共享材质
- 4	保持材质的数目尽可能少，更大程度的批处理
- 5	使用光照贴图(lightmap)而非实时灯光
- 6	使用LOD，好处就是对那些离得远，看不清的物体的细节可以忽略。
- 7	遮挡剔除（Occlusion culling）
- 8	利用网格的顶点数据（两个模型用了同一个材质为了不同但是之前用的两个材质多少有点不同，例如两棵树的颜色不同）
- 9	尽量少的使用反光啦，阴影啦之类的，因为那会使物体多次渲染
- 10  脚本动态合并mesh
#### 物理组件：
- 1）设置Fixed timestep，减少物理计算次数，提高游戏性能。
- 2）设置fps在60帧左右（Application.targetFrameRate = 60;），关闭垂直同步 ，设置帧率及使用相关帧率优化方案，在玩家不操作时降低帧率，操作时恢复帧率
- 优点：1.省电，减少手机发热的情况；2.能都稳定游戏FPS，减少出现卡顿的情况。
- 3）尽量不用MeshCollider
- 4）粒子组件，屏幕上最大粒子数量建议小于200个，粒子应尽可能的小，关闭粒子的碰撞功能。
- 5）真实物理（刚体）很消耗，不要轻易使用，尽量使用自己的代码模拟
- 6）对于投射物不要使用真实物理碰撞和刚体，自己模拟
- 7）设置较大的FixedTimeStep（物理帧率）值，减少cpu计算

### 三、GPU的优化


#### 顶点优化（减少顶点数量）
1. 优化几何体
2. 使用模型lod（Level of Detail）技术（unity中使用LOD Group组件）
3. 使用遮挡剔除（Occlusion Culling）技术
4. 使用mesh压缩

#### 片元优化（减少片元数量）（减少overdraw，overdraw指的就是一个像素被绘制了多次。透明物体）
1. overdraw的视图
2. 控制绘制顺序
    >2.1 在Unity中，那些Shader中被设置为“Geometry” 队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。而且，我们还可以充分利用Unity的队列来控制绘制顺序。例如，对于天空盒子来说，它几乎覆盖了所有的像素，而且我们知道它永远会在所有物体的后面，因此它的队列可以设置为“Geometry+1”。这样，就可以保证不会因为它而造成overdraws。
3. 时刻警惕透明物体
    >3.1 因此，如果场景中大面积的透明对象，或者有很多层覆盖的多层透明对象（即便它们每个的面积可以都不大），或者是透明的粒子效果，在移动设备上也会造成大量的overdraws。这是应该尽量避免的
4. 减少实时光照和阴影
    > 4.1 实时光照对于移动平台是个非常昂贵的操作。如果只有一个平行光还好，但如果场景中包含了太多光源并且使用了很多多Passes的shader，那么很有可能会造成性能下降。而且在有些机器上，还要面临shader失效的风险。例如，一个场景里如果包含了三个逐像素的点光源，而且使用了逐像素的shader，那么很有可能将Draw Calls提高了三倍，同时也会增加overdraws。这是因为，对于逐像素的光源来说，被这些光源照亮的物体要被再渲染一次。更糟糕的是，无论是动态批处理还是动态批处理（其实文档中只提到了对动态批处理的影响，但不知道为什么实验结果对静态批处理也没有用），对于这种逐像素的pass都无法进行批处理，也就是说，它们会中断批处理。
    > 4.2 使用Lightmaps和light probe（光照探针）
5. 减少使用法线贴图（或者在角色身上使用），静态物体尽量不要用，而是将法线渲染到贴图上
6. 尽量不使用fog雾效，或者使用简单的后处理雾效或者渐变的面片（参考shadow gun）    
7. 尽量减少alpha test的使用
#### 减少计算复杂度
1. 使用Shader的LOD技术
   1. 设置Shader.maximumLDO或者Shader.globalMaximumLOD来允许最大的LOD
2. Shader代码优化
   1. 把高斯模糊和边缘计算计算放到顶点shader中
   2. float存储顶点坐标等变量，half存储一些标量和纹理坐标等信息，fixed适用于大多数颜色变量和归一化的方向矢量
   3. 减少pow，sin，cos等函数使用
### 优化内存带宽：
- 1	减少纹理大小（压缩纹理，使用mipmap，mipmap图片渲染的质量比压缩要好））
- 2	使用mipmap。
    >Mipmap中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。因为存了主图和它的那些缩小的复制品，所以内存占用会比之前大。但是为何又优化了显存带宽呢？因为可以根据实际情况，选择适合的小图来渲染。所以，虽然会消耗一些内存，但是为了图片渲染的质量（比压缩要好），这种方式也是推荐的。
- 3 纹理压缩（ETC2 8bit，ASTC 4x4 block，PVRTC）
- 4 降低分辨率（Screen.SetResolution）
- 5 关闭图片ReadWrite


### UI优化

- 1.fillcenter
- 2.动静网格分离（通过增加canvas）
- 3.修改image的color会造成canvas.rebuildbatch  如果是颜色动画可以但是单独创建一个material 直接修改color，不会rebuild（动静网格分离）
- 4.EventSystem.Update（）消耗大  ，raycasttarget 关掉，分离canvas，需要的挂上GraphicRaycaster
- 5.图片如果是左右对称和上下对称可以使用mirrorImage类似的自定义Image组件，使用原始Sprite图片的四分之或者二分之一即可
- 6.图集尽量根据业务去划分



### 程序优化
- 删除空的脚本和不需要的默认方法（例如Update，Start）
- 避免使用OnGUI
- 同一脚本中频繁使用的变量建议声明全局变量
- 数组，集合类元素优先使用Array，其次是Queue/Stack,再次是List
- 合理的设置容器的初始化Capacity
- 应尽量为类或函数声明为sealed，变虚函数为直接函数调用
- 尽量减少闭包的使用
- 减少装箱和拆箱操作
- 减少Dictionary冗余操作
- 脚本在不使用时禁用，使用时启用
- 应减少不必要的Transform.position/rotation等访问
- 减少除法运算，例如a/5f,可以写成a*0.2f；
- 尽量直接声明脚本变量，而不是用Getcomponent来获取脚本组件
- 使用各种类的对象池和物体实例化池
- 减少使用sin，cos，pow等三角函数，如果使用量大则建议使用查表法来优化三角函数的计算量
- 尽量不要在Update中做复杂的计算，如果有需要在隔几帧计算一次
- 不要动态的生产字符串，例如使用Debug.Log（“a”+“b”），尽量预先创建好字符串资源，还有一个打印变量时不要用+号去链接也不要用$符去格式化，而是用Debug.logFormat去输出，这样关闭Debug时就能关闭和Debug输出相关的动态字符串
- 应使用支持Conditional的日志输出机制，支持log关闭
- 使用gameObject.name比较相等时尽量使用Equals
- String拼接时尽量使用System.Text.StringBuilder代替
- 避免频繁调用GameObject.SetActive
- 减少material频繁的set参数，如果量大，则使用字符串key获取唯一id

### 资源规范：

- 建筑升级的资源是拼接的（节省内存）
- 面数在1500以内将得到好的效率
- 不使用大的prefab 增加io的负担（多棵草做一个prefab）
- 每个模型只使用一个skinned mesh renderer
- 每个mesh不要超过2个material
- 骨骼数量不要超过30

### 模型方面

01、合并使用同贴图的材质球，合并使用相同材质球的Mesh； 　　

02、角色的贴图和材质球只要一个，若必须多个则将模型离分离为多个部分； 　　

02、骨骼系统不要使用太多，骨骼数量不要超过30； 　　

03、当使用多角色时，将动画单独分离出来；如果角色有多个动画，则将骨骼分离出来，导出动画不要带骨骼； 　　

04、使用层距离来控制模型的显示距离； 　　

05、阴影其实包含两方面阴暗和影子，建议使用实时影子时把阴暗效果烘焙出来，不要使用灯光来调节光线阴暗。 　　

06、少用像素灯和使用像素灯的Shader； 　　

08、如果硬阴影可以解决问题就不要用软阴影，并且使用不影响效果的低分辨率阴影； 　　

08、实时阴影很耗性能，尽量减小产生阴影的距离； 　　

09、允许的话在大场景中使用线性雾，这样可以使远距离对象或阴影不易察觉，因此可以通过减小相机和阴影距离来提高性能； 　　

10、使用圆滑组来尽量减少模型的面数； 　　

11、项目中如果没有灯光或对象在移动那么就不要使用实时灯光； 　　

12、水面、镜子等实时反射/折射的效果单独放在Water图层中，并且根据其实时反射/折射的范围来调整； 　　

13、碰撞对效率的影响很小，但碰撞还是建议使用Box、Sphere碰撞体； 　　

14、建材质球时尽量考虑使用Substance； 　　

15、尽量将所有的实时反射/折射（如水面、镜子、地板等等）都集合成一个面； 　　

16、假反射/折射没有必要使用过大分辨率，一般64*64就可以，不建议超过256*256； 　　

17、需要更改的材质球，建议实例化一个，而不是使用公共的材质球； 　　

18、将不须射线或碰撞事件的对象置于IgnoreRaycast图层； 　　

19、将水面或类似效果置于Water图层 　　

20、将透明通道的对象置于TransparentFX图层； 　　

21、养成良好的标签（Tags）、层次（Hieratchy）和图层（Layer）的条理化习惯，将不同的对象置于不同的标签或图层，三者有效的结合将很方便的按名称、类别和属性来查找； 　　

22、通过Stats和Profile查看对效率影响最大的方面或对象，或者使用禁用部分模型的方式查看问题到底在哪儿； 　　

23、使用遮挡剔除（Occlusion Culling）处理大场景，一种较原生的类LOD技术，并且能够“分割”作为整体的一个模型。

### Unity优化工具
- MAT（Memory Analyzer Tool） 需要导入HPROF文件再分析 只能查看java层的内存情况，看不到native堆的详情
- Xcode Instrument工具 只能用于Mac,iOS 只能查看C++ 或 object C 的情况，看不到mono堆的详情
- Unity自带Profiler 需要单独编译develop版本 在PC上执行，没法捕获真机数据 内存数据跟实际真机的数据差异很大、多的时候有几十M差距 只能看到最近一段时间的数据，看不到总体的详情
- 官方开源Memory Profiler
- Unity5.3及其以上
- 使用IL2CPP
- 构建时开启Development Build
- UWA
- WeTest PerfDog性能狗



> - 加载类型(Load Type)： 运行时Unity加载音频的方法。
>    - 加载时解压缩(Decompress on load): 加载后解压缩声音。使用于较小的压缩声音，以避免运行时解压缩的性能开销。(将使用比在它们在内存中压缩的多10倍或更多内存，因此大文件不要使用这个。)
>    - 在内存中压缩(Compressed in memory): 保持声音在内存中（压缩的）在播放时解压缩。这有轻微的性能开销（尤其是OGG / Vorbis格式的压缩文件），因此大文件使用这个。
>    - 从磁盘流(Stream from disc): 直接从磁盘流读取音频数据。这只使用了原始声音占内存大小的很小一部分。使用这个用于很长的音乐。取决于硬件，一般建议1-2线程同时流。
> - Ui动画：帧动画、Animation、脚本动画
