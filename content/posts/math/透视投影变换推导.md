---
title: "透视投影(Perspective Projection)变换推导过程"
subtitle: "透视投影(Perspective Projection)变换推导过程"
date: 2021-04-21T20:09:51+08:00
author: "codingriver"
authorLink: "https://codingriver.github.io"
draft: true
tags: []
categories: []
---

<!--more-->


>转自：<http://blog.csdn.net/popy007/article/details/1797121> 


透视投影是3D固定流水线的重要组成部分，是将相机空间中的点从视锥体(frustum)变换到规则观察体(Canonical View Volume)中，待裁剪完毕后进行透视除法的行为。在算法中它是通过透视矩阵乘法和透视除法两步完成的。

 

透视投影变换是令很多刚刚进入3D图形领域的开发人员感到迷惑乃至神秘的一个图形技术。其中的理解困难在于步骤繁琐，对一些基础知识过分依赖，一旦对它们中的任何地方感到陌生，立刻导致理解停止不前。

没错，主流的3D APIs如OpenGL、D3D的确把具体的透视投影细节封装起来，比如

gluPerspective(…)就可以根据输入生成一个透视投影矩阵。而且在大多数情况下不需要了解具体的内幕算法也可以完成任务。但是你不觉得，如果想要成为一个职业的图形程序员或游戏开发者，就应该真正降伏透视投影这个家伙么？我们先从必需的基础知识着手，一步一步深入下去（这些知识在很多地方可以单独找到，但我从来没有在同一个地方全部找到，但是你现在找到了）。

我们首先介绍两个必须掌握的知识。有了它们，我们才不至于在理解透视投影变换的过程中迷失方向（这里会使用到向量几何、矩阵的部分知识，如果你对此不是很熟悉，可以参考[《向量几何在游戏编程中的使用》](http://blog.csdn.net/popy007)系列文章）

### 1.齐次坐标

---

透视投影变换是在齐次坐标下进行的，而齐次坐标本身就是一个令人迷惑的概念，这里我们先把它理解清楚。

简短的解释：`齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示。`

    “齐次坐标表示是计算机图形学的重要手段之一，它既能够用来明确区分向量和点，同时也更易用于进行仿射（线性）几何变换。”—— F.S. Hill, JR

>参考：[齐次坐标的意义](齐次坐标的意义.md)

### 2.线性插值

---

这是在图形学中普遍使用的基本技巧，我们在很多地方都会用到，比如2D位图的放大、缩小，Tweening变换，以及我们即将看到的透视投影变换等等。基本思想是：给一个x属于[a, b]，找到y属于[c, d]，使得x与a的距离比上ab长度所得到的比例，等于y与c的距离比上cd长度所得到的比例，用数学表达式描述很容易理解：

![20210421231520](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231520.png)


这样，从a到b的每一个点都与c到d上的唯一一个点对应。有一个x，就可以求得一个y。

此外，如果x不在[a, b]内，比如x < a或者x > b，则得到的y也是符合y < c或者y > d，比例仍然不变，插值同样适用。

## 投影变换

---

好，有了上面两个理论知识，我们开始分析这次的主角——透视投影变换。这里我们选择OpenGL的透视投影变换进行分析，其他的APIs会存在一些差异，但主体思想是相似的，可以类似地推导。经过相机矩阵的变换，顶点被变换到了相机空间。这个时候的多边形也许会被视锥体裁剪，但在这个不规则的体中进行裁剪并非那么容易的事情，所以经过图形学前辈们的精心分析，裁剪被安排到规则观察体(Canonical View Volume, CVV)中进行，CVV是一个正方体，x, y, z的范围都是[-1，1]，多边形裁剪就是用这个规则体完成的。所以，事实上是透视投影变换由两步组成：

 

1）  用透视变换矩阵把顶点从视锥体中变换到裁剪空间的CVV中。

2）  CVV裁剪完成后进行透视除法（一会进行解释）。

![20210421231724](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231724.png)

我们一步一步来，我们先从一个方向考察投影关系。

![20210421231739](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231739.png)

上图是右手坐标系中顶点在相机空间中的情形。设P(x,z)是经过相机变换之后的点，视锥体由eye——眼睛位置，np——近裁剪平面，fp——远裁剪平面组成。N是眼睛到近裁剪平面的距离，F是眼睛到远裁剪平面的距离。投影面可以选择任何平行于近裁剪平面的平面，这里我们选择近裁剪平面作为投影平面。设P’(x’,z’)是投影之后的点，则有z’ = -N。通过相似三角形性质，我们有关系：

![20210421231755](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231755.png)

同理，有


![20210421231811](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231811.png)

这样，我们便得到了P投影后的点P’

![20210421231826](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231826.png)

从上面可以看出，投影的结果z’始终等于-N，在投影面上。实际上，z’对于投影后的P’已经没有意义了，这个信息点已经没用了。但对于3D图形管线来说，为了便于进行后面的片元操作，例如z缓冲消隐算法，有必要把投影之前的z保存下来，方便后面使用。因此，我们利用这个没用的信息点存储z，处理成：

![20210421231834](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231834.png)

这个形式最大化地使用了3个信息点，达到了最原始的投影变换的目的，但是它太直白了，有一点蛮干的意味，我感觉我们最终的结果不应该是它，你说呢？我们开始结合CVV进行思考，把它写得在数学上更优雅一致，更易于程序处理。假入能够把上面写成这个形式：

 ![20210421231853](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231853.png)

那么我们就可以非常方便的用矩阵以及齐次坐标理论来表达投影变换：

 
![20210421231902](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231902.png)

其中

 
![20210421231918](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231918.png)


 

哈，看到了齐次坐标的使用，这对于你来说已经不陌生了吧？这个新的形式不仅达到了上面原始投影变换的目的，而且使用了齐次坐标理论，使得处理更加规范化。注意在把

![20210421231959](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421231959.png)
变成
![20210421232008](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232008.png) 
的一步我们是使用齐次坐标变普通坐标的规则完成的。这一步在透视投影过程中称为透视除法（Perspective Division），这是透视投影变换的第2步，经过这一步，就丢弃了原始的z值（得到了CVV中对应的z值，后面解释），顶点才算完成了投影。而在这两步之间的就是CVV裁剪过程，所以裁剪空间使用的是齐次坐标
![20210421232043](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232043.png)
，主要原因在于透视除法会损失一些必要的信息（如原始z，第4个-z保留的）从而使裁剪变得更加难以处理，这里我们不讨论CVV裁剪的细节，只关注透视投影变换的两步。

矩阵

![20210421232055](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232055.png)

就是我们投影矩阵的第一个版本。你一定会问为什么要把z写成

![20210421232116](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232116.png)


 

>有三个原因：  
>1. 后面投影之后的光栅化阶段，要通过x'和y'对z进行线性插值，以求出三角形内部片元的z，进行z缓冲深度测试。在数学上，投影后的x'和y'，与z不是线性关系，与1/z才是线性关系。而正
   ![20210421232253](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232253.png)
   是1/z的线性关系，即-a+b/z。用这个1/z的线性组合值和x'、y'进行插值才是正确的。
>2.  P’的3个代数分量统一地除以分母-z，易于使用齐次坐标变为普通坐标来完成，使得处理更加一致、高效。
>3. 后面的CVV是一个x,y,z的范围都为[-1，1]的规则体，便于进行多边形裁剪。而我们可以适当的选择系数a和b，使得
   ![20210421232329](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232329.png)
   这个式子在z = -N的时候值为-1，而在z = -F的时候值为1，从而在z方向上构建CVV。

*上面是原始作者列举的原因，但我认为主要是一个原因*：`由于在光栅化的过程中，要进行 Z 坐标的倒数的插值`,参考[透视校正插值](透视校正差值.md))。

接下来我们就求出a和b：

![20210421232345](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232345.png)

 
这样我们就得到了透视投影矩阵的第一个版本：

![20210421232402](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232402.png)

使用这个版本的透视投影矩阵可以从z方向上构建CVV，但是x和y方向仍然没有限制在[-1,1]中，我们的透视投影矩阵的下一个版本就要解决这个问题。

为了能在x和y方向把顶点从Frustum情形变成CVV情形，我们开始对x和y进行处理。先来观察我们目前得到的最终变换结果：

![20210421232434](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232434.png)

我们知道-Nx / z的有效范围是投影平面的左边界值（记为left）和右边界值（记为right），即[left, right]，-Ny / z则为[bottom, top]。而现在我们想把-Nx / z属于[left, right]映射到x属于[-1, 1]中，-Ny / z属于[bottom, top]映射到y属于[-1, 1]中。你想到了什么？哈，就是我们简单的线性插值，你都已经掌握了！我们解决掉它：


![20210421232451](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232451.png)

则我们得到了最终的投影点：

![20210421232614](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232614.png)

下面要做的就是从这个新形式出发反推出下一个版本的透视投影矩阵。注意到
![20210421232635](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232635.png)
是
![20210421232644](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232644.png)
经过透视除法的形式，而P’只变化了x和y分量的形式，az+b和-z是不变的，则我们做透视除法的逆处理——给P’每个分量乘上-z，得到

![20210421232712](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232712.png)






而这个结果又是这么来的：

![20210421232720](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232720.png)


则我们最终得到：

![20210421232726](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232726.png)


M就是最终的透视变换矩阵。相机空间中的顶点，如果在视锥体中，则变换后就在CVV中。如果在视锥体外，变换后就在CVV外。而CVV本身的规则性对于多边形的裁剪很有利。OpenGL在构建透视投影矩阵的时候就使用了M的形式。注意到M的最后一行不是(0 0 0 1)而是(0 0 -1 0)，因此可以看出透视变换不是一种仿射变换，它是非线性的。另外一点你可能已经想到，对于投影面来说，它的宽和高大多数情况下不同，即宽高比不为1，比如640/480。而CVV的宽高是相同的，即宽高比永远是1。这就造成了多边形的失真现象，比如一个投影面上的正方形在CVV的面上可能变成了一个长方形。解决这个问题的方法就是在对多变形进行透视变换、裁剪、透视除法之后，在归一化的设备坐标(Normalized Device Coordinates)上进行的视口(viewport)变换中进行校正，它会把归一化的顶点之间按照和投影面上相同的比例变换到视口中，从而解除透视投影变换带来的失真现象。进行校正前提就是要使投影平面的宽高比和视口的宽高比相同。

 

便利的投影矩阵生成函数

 

3D APIs都提供了诸如gluPerspective(fov, aspect, near, far)或者D3DXMatrixPerspectiveFovLH(pOut, fovY, Aspect, zn, zf)这样的函数为用户提供快捷的透视矩阵生成方法。我们还是用OpenGL的相应方法来分析它是如何运作的。

 

gluPerspective(fov, aspect, near, far)

 

fov即视野，是视锥体在xz平面或者yz平面的开角角度，具体哪个平面都可以。OpenGL和D3D都使用yz平面。

 

aspect即投影平面的宽高比。

 

near是近裁剪平面的距离

 

far是远裁剪平面的距离。

![20210421232759](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421232759.png)



上图中左边是在xz平面计算视锥体，右边是在yz平面计算视锥体。可以看到左边的第3步top = right / aspect使用了除法（图形程序员讨厌的东西），而右边第3步right = top x aspect使用了乘法，这也许就是为什么图形APIs采用yz平面的原因吧！

 

到目前为止已经完成了对透视投影变换的阐述，我想如果你一直跟着我的思路下来，应该能够对透视投影变换有一个细节层次上的认识。当然，很有可能你已经是一个透视投影变换专家，如果是这样的话，一定给我写信，指出我认识上的不足，我会非常感激。Bye!

## Unity中透视投影变换

---

根据上面推导的结果按照右边yz平面计算视锥体，得出最终Unity中用的透视矩阵：

![20210421235050](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421235050.png)


![20210421235111](https://cdn.jsdelivr.net/gh/codingriver/cdn/texs/透视投影变换推导/20210421235111.png)

*按照OpenGL计算的，不讨论DirectX*

> 参考文章
>   
> <https://blog.csdn.net/popy007/article/details/376952>  
> <https://blog.csdn.net/linuxheik/article/details/78969526>
> <https://blog.csdn.net/lzhq1982/article/details/73612170>



><https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix>  
><http://frankorz.com/2020/07/26/transformation/>