---
title: "unity优化"
date: 2019-12-01T21:57:40+08:00
draft: true
author: "codingriver"
authorLink: "https://codingriver.github.io"
tags: [""]
categories: [""]
---

<!--more-->


### 一、内存的优化：
Unity中的内存种类
- 实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。 

优化程序代码的内存占用
- 1 API兼容性级别选择.net2.0子集（不需要Unity将全部.NET的Api包含进去）
- 2剥离级别选择剥离字符集（示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分）
 
托管堆优化

1. 建立缓存池
1. 在卸载场景时调用System.GC.Collect()（调用System.GC.Collect() 会卡顿）
1. 尽量不要用foreach（带来24字节）
1. 不要直接访问gameobject的tag属性(可以用if (go.CompareTag (“human”))， 因为访问物体的tag属性会在堆上额外的分配空间)
1. Debug.Log 游戏发布关闭 Log 减少性能消耗
 
本机堆的优化

- 1 纹理
- 1.1使用png格式
- 1.2关闭纹理资源的read/write功能（增加1倍） ui不适用mipmap（增加1/3）
- 1.3非二次幂的纹理（不压缩 ，ui图集，可以是非正方形）
- 1.4Ui的背景可以适当的压缩，其他ui资源不压缩（防止糊了）
- 1.5Android平台贴图压缩用etc2 8bit，占用原来的1/4内存（etc 8bit注意下）
- 1.6Ios平台贴图压缩用pvrtc 4bit 占用原来的1/8内存（必须是正方形）
- 1.7压缩贴图的话贴图本身必须是二次幂的
- 2 音频
- 2.1 背景音乐使用压缩的ogg或者mp3，像攻击音效等使用wav
- 2.2 背景音乐等长的音频使用在内存中压缩(Compressed in memory)的加载类型
- 2.3 攻击音效等短的音频使用加载时解压(Decompress on load)的加载类型
- 2.4 加载时解压是在内存中压缩的10倍内存， 但是像攻击音效等短的音效如果用在内存中压缩的加载类型的话会有延时（需要先解压），这样体验不好（本来音频就很短）
- 3 网格
- 3.1模型资源不要开启read/write  使用 Mesh Compression 压缩网格
- 3.2 不要使用自带的球体网格，面数太多

资源规范：

- 1	 建筑升级的资源是拼接的（节省内存）
- 2面数在1500以内将得到好的效率
- 3不使用大的prefab 增加io的负担（多棵草做一个prefab）
- 4每个模型只使用一个skinned mesh renderer
- 5每个mesh不要超过2个material
- 6骨骼数量不要超过30

### 二、CPU的方面的优化： 
>Drawcall：
>Drawcall是啥？其实就是对底层图形程序（比如：OpenGL ES)接口的调用，以在屏幕上画出东西。

#### DrawCall如何优化：
- 1	使用Draw Call Batching，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，从而用一个描绘调用来渲染他们。
  - 静态批处理Static Batching，只要是静态不动的物体且具有相同材质的话就可以使用静态批处理来降低描绘调用（注：shader不同则会增加纹理的拼合降低渲染效率）
  - 动态批处理Dynamic Batching：动态批处理是引擎自动进行，无需设置，当物体共享相同的材质，则引擎就会自动对Drawcall进行优化，也就是动态批处理（如实例化预制件）。动态批处理存在约束，稍有不慎就会增加Drawcall
    >动态批处理的约束：  
    > 1、批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。  
    >2、如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。  
    >3、不要使用缩放。分别拥有缩放大小(1,1,1) 和(2,2,2)的两个物体将不会进行批处理。  
    >4、统一缩放的物体不会与非统一缩放的物体进行批处理。  
    >5、使用缩放尺度(1,1,1) 和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1) 和(1,3,1)的两个物体将可以进行批处理。  
    >6、使用不同材质的实例化物体（instance）将会导致批处理失败。  
    >7、拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。  
    >8、多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。  
    >9、预设体的实例会自动地使用相同的网格模型和材质。  
    >所以尽量使用静态批处理。


- 2	打包图集
- 3	使用共享材质
- 4	保持材质的数目尽可能少，更大程度的批处理
- 5	使用光照贴图(lightmap)而非实时灯光
- 6	使用LOD，好处就是对那些离得远，看不清的物体的细节可以忽略。
- 7	遮挡剔除（Occlusion culling）
- 8	利用网格的顶点数据（两个模型用了同一个材质为了不同但是之前用的两个材质多少有点不同，例如两棵树的颜色不同）
- 9	尽量少的使用反光啦，阴影啦之类的，因为那会使物体多次渲染
- 10  脚本动态合并mesh
#### 物理组件：
- 1）设置Fixed timestep，减少物理计算次数，提高游戏性能。
- 2）设置fps在30帧左右（Application.targetFrameRate = 30;），关闭垂直同步 
- 优点：1.省电，减少手机发热的情况；2.能都稳定游戏FPS，减少出现卡顿的情况。
- 3）尽量不用MeshCollider
- 4）粒子组件，屏幕上最大粒子数量建议小于200个，粒子应尽可能的小，关闭粒子的碰撞功能。
  
#### 代码：
- 1）不要频繁使用GetComponent去频繁获取组件，如使用可在Awake函数中持有引用。
- 2）善于使用OnBecameVisible()和OnBecameInvisible()来控制物体的Update()函数的执行以减少开销。
- 3）使用内建数组如使用Vector3.zero而不是new Vector(0,0,0);
- 4）数组、集合类元素优先使用Array，其次是List;
- 5）尽量少用开方运算和除法运算，比如a/5f，一定要写成a*0.2f，不要使用三角函数
- 6）像几秒调用一次的方法不要写到Update中，

### 三、GPU的优化：
#### 优化显存带宽：
- 1	减少纹理大小（压缩纹理，使用mipmap，mipmap图片渲染的质量比压缩要好））
- 2	使用mipmap。
    >Mipmap中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。因为存了主图和它的那些缩小的复制品，所以内存占用会比之前大。但是为何又优化了显存带宽呢？因为可以根据实际情况，选择适合的小图来渲染。所以，虽然会消耗一些内存，但是为了图片渲染的质量（比压缩要好），这种方式也是推荐的。

#### 顶点优化
- 1 尽可能减少模型中三角形的数目,对于GPU来说，它本质上只关心有多少个顶点。因此，尽可能减少顶点的数目其实才是我们真正对需要关心的事情。因此，最后一条优化建议就是：移除不必要的Hard Edge以及纹理衔接，即避免Smoothing splits和UV splits。
- 2 使用LOD（Level of detail）技术
- 3 使用遮挡剔除（Occlusion culling）技术

#### 像素优化（减少overdraw，overdraw指的就是一个像素被绘制了多次。透明物体）
- 1 overdraw的视图
- 2 控制绘制顺序
    >2.1 在Unity中，那些Shader中被设置为“Geometry” 队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。而且，我们还可以充分利用Unity的队列来控制绘制顺序。例如，对于天空盒子来说，它几乎覆盖了所有的像素，而且我们知道它永远会在所有物体的后面，因此它的队列可以设置为“Geometry+1”。这样，就可以保证不会因为它而造成overdraws。
- 3 时刻警惕透明物体
    >3.1 因此，如果场景中大面积的透明对象，或者有很多层覆盖的多层透明对象（即便它们每个的面积可以都不大），或者是透明的粒子效果，在移动设备上也会造成大量的overdraws。这是应该尽量避免的
- 4 减少实时光照
    > 4.1 实时光照对于移动平台是个非常昂贵的操作。如果只有一个平行光还好，但如果场景中包含了太多光源并且使用了很多多Passes的shader，那么很有可能会造成性能下降。而且在有些机器上，还要面临shader失效的风险。例如，一个场景里如果包含了三个逐像素的点光源，而且使用了逐像素的shader，那么很有可能将Draw Calls提高了三倍，同时也会增加overdraws。这是因为，对于逐像素的光源来说，被这些光源照亮的物体要被再渲染一次。更糟糕的是，无论是动态批处理还是动态批处理（其实文档中只提到了对动态批处理的影响，但不知道为什么实验结果对静态批处理也没有用），对于这种逐像素的pass都无法进行批处理，也就是说，它们会中断批处理。
- 5 使用Lightmaps
- 6 使用God Rays（场景中很多小型光源效果都是靠这种方法模拟的。它们一般并不是真的光源产生的，很多情况是通过透明纹理进行模拟）











很多时候分辨率也是造成性能下降的原因，尤其是现在很多国内山寨机，除了分辨率高其他硬件简直一塌糊涂，而这恰恰中了游戏性能的两个瓶颈：过大的屏幕分辨率+糟糕的GPU。因此，我们可能需要对于特定机器进行分辨率的放缩。当然，这样会造成游戏效果的下降，但性能和画面之间永远是个需要权衡的话题。
在Unity中设置屏幕分辨率可以直接调用Screen.SetResolution


加载类型(Load Type)： 运行时Unity加载音频的方法。
加载时解压缩(Decompress on load): 加载后解压缩声音。使用于较小的压缩声音，以避免运行时解压缩的性能开销。(将使用比在它们在内存中压缩的多10倍或更多内存，因此大文件不要使用这个。)
在内存中压缩(Compressed in memory): 保持声音在内存中（压缩的）在播放时解压缩。这有轻微的性能开销（尤其是OGG / Vorbis格式的压缩文件），因此大文件使用这个。
从磁盘流(Stream from disc): 直接从磁盘流读取音频数据。这只使用了原始声音占内存大小的很小一部分。使用这个用于很长的音乐。取决于硬件，一般建议1-2线程同时流。

Ui动画：帧动画、Animation、脚本动画



ugUi优化
1.fillcenter
2.动静网格分离（通过增加canvas，）
3.修改image的color会造成canvas.rebuildbatch  如果是颜色动画可以但是单独创建一个material 直接修改color，不会rebuild（动静网格分离）
4.EventSystem.Update（）消耗大  ，raycasttarget 关掉，分离canvas，需要的挂上GraphicRaycaster
5.


插件MeshBaker 合并蒙皮mesh